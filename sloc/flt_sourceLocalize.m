function [signal, state] = flt_sourceLocalize(varargin)
% Localize sources for a given head model.
% Estimated sources and inverse operator will be stored in 
% signal.CSD and signal.invOperator
% 
% Author: Tim Mullen, Jan 2013, SCCN/INC/UCSD
%         Alejandro Ojeda, Jan 2013, SCCN/INC/UCSD
%         Christian Kothe, Jan 2013, SCCN/INC/UCSD

% FIXME: Need to add a for loop over the calls to Loreta (or add it in the
% flt_loreta function) which loops over sub-partitions of the data block,
% estimating CSD for each partition (i.e. assuming local stationarity of 
% the inverse operator within each partition). The invOperator results are 
% stored in a 3D array and the mean invOperator is then returned in state
% obj as well as in signal obj.
% FIXME: Implement option to only update inverse operatior infrequently,
% otherwise using the inv op stored in state object (i.e. mean over last
% block).

if ~exp_beginfun('filter'), return; end

declare_properties('name','SourceLocalization', 'follows',{'flt_ica'}, 'precedes',{'set_fit_dipoles'},'independent_channels',false, 'independent_trials',false);

% extract some defaults
hmObj       = arg_extract(varargin,{'hmObj','HeadModelObject'});
ROINames    = hmObj.atlas.label';

arg_define(varargin, ...
    arg_norep({'hmObj','HeadModelObject'},mandatory,[],'Head model object generated by MOBILAB. See MOBILAB''s headModel class.'), ...
    arg_norep({'signal','Signal'},mandatory,[],'Signal structure. Must contain .data field with channel data'), ...
    arg({'channels','Channels'},[],[],'Cell array of channel labels to retain. If empty, all channels in signal.chanlocs.labels will be used. Channels must be a subset of hmObj.getChannelLabels()','type','cellstr','shape','row'), ...
    arg_subswitch({'invMethod','InverseMethod'},{'LORETA'}, ...
    {...
     'LORETA', @flt_loreta ...
     },'Source Localization Algorithm'), ...
    arg({'roiLabels','RegionsOfInterest','ROI'},{},ROINames,'Regions of interest (labels). This is a cell array of strings corresponding to a subset of the labels stored in hmObj.atlas.label. Current source density will be estimated only for these ROIs.','type','logical'), ...
    arg_nogui({'roiVertices','ROIVertices'},[],[],'Regions of interest (vertices). This is supplementary to the ''RegionsOfInterest'' option. ''roiVertices'' is a cell array where each cell contains the indices of all vertices within a region of interest. The vertex indices correspond to respective columns of the lead field matrix. These ROIs will be added to the set of ROIs defined in the ''RegionsOfInterest'' option.'), ...
    arg({'colRoiCsd','CollapseRoiCsd'},'sum',{'none','mean','sum','max'},'Method for computing ROI CSD. Return the (mean, integral, max) current source density within each ROI. signal.CSD matrix will be reduced to [num_rois x num_samples].'), ...
    arg({'makeDipfitStruct','MakeDipfitStruct'},true,[],'Make dipfit structure. If selected, a dipfit structure will be created containing the locations (.posxyz) and moments (.mom) of each dipole or center of mass of ROI.'), ... 
    arg({'verb','Verbosity'},false,[],'Verbose output'), ...
    arg_nogui({'state','State'}));

% Intialization block
% -------------------------------------------------------------------------
if isempy(state) ...
    || (isfield(state,'roiLabels') && ~isequal(state.roiLabels,roiLabels))
    % Either we are initializing our adaptive estimator or user-specified 
    % ROIs have changed.
    
    if verb
        fprintf('Initializing source reconstructor \n');
    end
    
    % Prune lead field matrix and laplacian operator
    % to contain only regions of interest
    % If there are no specific ROIs selected, this will "open" the 
    % surface mesh by removing a few vertices 
    % (the surface mesh cannot be a closed surface)
    brainStructsToRemove = setdiff(hmObj.atlas.label,roiLabels);
    [~,                                 ...
     state.leadFieldMatrix,             ...
     state.laplacianOperator            ...
     ] = getSourceSpace4PEB(hmObj,brainStructsToRemove);
    
    % We also store the indices of the vertices that were removed in a cell 
    % array for later integration over current source density (CSD) within
    % each ROI to obtain single CSD estimate for each ROI
    for k=1:length(state.brainStructsToRemove)
        state.roiVertices{k} = indices4Structure(hmObj,state.brainStructsToRemove{k});
%         [~,state.roiVertices{k}] = removeStructureFromSourceSpace(hmObj,state.brainStructsToRemove{k});
    end
    
    % append any additional ROI defined by 'roiVertices' input argument
    state.roiVertices = [state.roiVertices roiVertices];
    state.solverState = [];
    
    state.sourceSpace = hmObj.surfaces;
    
    % prune the lead field matrix to contain only desired channels
    hmChanlabels  = hmObj.getChannelLabels();
    if isempty(channels)
        if isfield(signal,'chanlocs')
            channels = {signal.chanlocs.labels};
        else
            fprintf(['flt_sourceLocalize: Warning!\n' ...
                     'Channel labels were not supplied and could not look up labels in signal.chanlocs\n' ...
                     'Assuming channels are identical to those in head model. Results may be incorrect.']);
            channels = hmChanlabels;
        end
    end
    
    % use only selected channels that are in the head model
    chaninds = ismember(hmChanlabels,channels);
    state.leadFieldMatrix = state.leadFieldMatrix(chaninds,:);
    
end

state.roiLabels = roiLabels;

% Estimate Current Source Density
% -------------------------------------------------------------------------

% Current source density is returned in signal.srcpot 
% [num_vertices x num_samples] 
% Inverse operator is returned in signal.srcweights   
% [num_vertices x num_channels]

if verb
    fprintf('Estimating current source density using %s \n', ...
            invMethod.arg_selection); 
end

switch lower(invMethod.arg_selection)
    case 'loreta'
        [signal, state.solverState] = flt_loreta('signal',signal,   ...
                                      invMethod.LORETA,             ...
                                     'state',state.solverState,     ...
                                     'K',state.leadFieldMatrix,     ...
                                     'L',state.laplacianOperator);                 
       signal.srcweights = state.solverState.srcweights;
    otherwise
        error('flt_sourceLocalize:badInverseMethod','Invalid inverse method %s',invMethod.arg_selection);
end

% Collapse CSD within each ROI
% -------------------------------------------------------------------------
% FIXME: We may wish to replace avg with the surface integral over the ROI
% We can use numerical double integration i.e. quad2d() or more crudely:
% sum(signal.CSD(x,:)) * dx * dy;
% where dx, dy are the voxel x,y dimensions.
% If the csd is not constrained to the surface of a mesh, then we need to
% use triple integration i.e. triplequad(). Or
% sum(signal.CSD(x,:) * dx * dy * dz

if ~strcmp(colRoiCsd,'none')
    if verb
        fprintf('Computing %s CSD for each ROI \n', colRoiCsd); 
    end
    
    nrois = length(state.roiVertices);
    szact = size(signal.srcpot);
    szwgt = size(signal.srcweights);

    % initialization
    srcpot = zeros(nrois,szact(2:end));
    csdwgt = zeros(nrois,szwgt(2:end));
    
    switch colRoiCsd
        case 'mean'
            % average CSD for each ROI
            for k=1:nrois
                srcpot(k,:) = mean(signal.srcpot(x,:),1);
                csdwgt(k,:) = mean(signal.srcweights(x,:),1);
            end
        case 'sum'
            % sum CSD for each ROI
            for k=1:nrois
                srcpot(k,:) = sum(signal.srcpot(x,:),1);
                csdwgt(k,:) = sum(signal.srcweights(x,:),1);
            end
        case 'max'
            % get max CSD for each ROI
            for k=1:nrois
                srcpot(k,:) = max(signal.srcpot(x,:),[],1);
                csdwgt(k,:) = max(signal.srcweights(x,:),[],1);
            end
    end
    
    signal.srcpot     = srcpot;
    signal.srcweights = srcwgt;
end


% OLD METHOD (simulation shows loop is faster)
% switch colRoiCsd
%     case 'mean'
%         % average CSD for each ROI
%         roifunc_csd = @(x) mean(signal.srcpot(x,:),1);
%         roifunc_inv = @(x) mean(signal.srcweights(x,:),1);
%     case 'sum'
%         % sum CSD for each ROIs
%         roifunc_csd = @(x) sum(signal.srcpot(x,:),1);
%         roifunc_inv = @(x) sum(signal.srcweights(x,:),1);
%     case 'max'
%         % get max CSD for each ROI
%         roifunc_csd = @(x) max(signal.srcpot(x,:),[],1);
%         roifunc_inv = @(x) max(signal.srcweights(x,:),[],1);
% end
% 
% if ~strcmp(colRoiCsd,'none')
%     if verb
%         fprintf('Computing %s CSD for each ROI \n', colRoiCsd); 
%     end
%     roicsd = cellfun(roifunc_csd,state.roiVertices,'UniformOutput',false);
%     invcsd = cellfun(roifunc_inv,state.roiVertices,'UniformOutput',false);
%     signal.srcpot         = cell2mat(roicsd');
%     signal.srcweights     = cell2mat(invcsd');
% end
    
exp_endfun;


